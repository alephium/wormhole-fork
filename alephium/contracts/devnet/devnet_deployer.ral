Contract DevnetDeployer() {
  @using(preapprovedAssets = true)
  pub fn deployGovernance(
    bytecode: ByteVec,
    chainId: U256,
    governanceChainId: U256,
    governanceEmitterAddress: ByteVec,
    receivedSequence: U256,
    messageFee: U256,
    guardianSets: [ByteVec; 2],
    guardianSetIndexes: [U256; 2],
    previousGuardianSetExpirationTime: U256
  ) -> () {
    let encodedState = encodeToByteVec!(
      chainId,
      governanceChainId,
      governanceEmitterAddress,
      receivedSequence,
      messageFee,
      guardianSets[0],
      guardianSets[1],
      guardianSetIndexes[0],
      guardianSetIndexes[1],
      previousGuardianSetExpirationTime
    )
    createSubContract!{callerAddress!() -> 1 alph}(#00, bytecode, encodedState)
  }

  @using(preapprovedAssets = true)
  pub fn deployTokenBridge(
    bytecode: ByteVec,
    governanceContractId: ByteVec,
    localChainId: U256,
    receivedSequence: U256,
    sendSequence: U256,
    wrappedAlphId: ByteVec,
    wrappedAlphPoolTemplateId: ByteVec,
    localTokenPoolTemplateId: ByteVec,
    remoteTokenPoolTemplateId: ByteVec,
    tokenBridgeForChainTemplateId: ByteVec,
    attestTokenHandlerTemplateId: ByteVec,
    undoneSequenceTemplateId: ByteVec,
    refundAddress: Address,
    minimalConsistencyLevel: U256
  ) -> () {
    let encodedState = encodeToByteVec!(
      governanceContractId,
      localChainId,
      receivedSequence,
      sendSequence,
      wrappedAlphId,
      wrappedAlphPoolTemplateId,
      localTokenPoolTemplateId,
      remoteTokenPoolTemplateId,
      tokenBridgeForChainTemplateId,
      attestTokenHandlerTemplateId,
      undoneSequenceTemplateId,
      refundAddress,
      minimalConsistencyLevel
    )
    createSubContract!{callerAddress!() -> 1 alph}(#01, bytecode, encodedState)
  }

  @using(preapprovedAssets = true)
  pub fn deployWrappedAlph(bytecode: ByteVec) -> () {
    let encodedState = encodeToByteVec!(0)
    createSubContractWithToken!{callerAddress!() -> 1 alph}(#02, bytecode, encodedState, 1e9 alph)
  }
}
