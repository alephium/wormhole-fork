Contract DevnetDeployer() {
  @using(preapprovedAssets = true)
  pub fn deployGovernance(
    bytecode: ByteVec,
    chainId: U256,
    governanceChainId: U256,
    governanceEmitterAddress: ByteVec,
    receivedSequence: U256,
    messageFee: U256,
    guardianSets: [ByteVec; 2],
    guardianSetIndexes: [U256; 2],
    previousGuardianSetExpirationTimeMS: U256
  ) -> () {
    let encodedFields = encodeToByteVec!(
      chainId,
      governanceChainId,
      governanceEmitterAddress,
      receivedSequence,
      messageFee,
      guardianSets[0],
      guardianSets[1],
      guardianSetIndexes[0],
      guardianSetIndexes[1],
      previousGuardianSetExpirationTimeMS
    )
    createSubContract!{callerAddress!() -> 1 alph}(#00, bytecode, encodedFields)
  }

  @using(preapprovedAssets = true)
  pub fn deployTokenBridge(
    bytecode: ByteVec,
    governance: Governance,
    localChainId: U256,
    receivedSequence: U256,
    sendSequence: U256,
    wrappedAlphId: ByteVec,
    tokenBridgeFactory: TokenBridgeFactory,
    minimalConsistencyLevel: U256
  ) -> () {
    let encodedFields = encodeToByteVec!(
      governance,
      localChainId,
      receivedSequence,
      sendSequence,
      wrappedAlphId,
      tokenBridgeFactory,
      minimalConsistencyLevel
    )
    createSubContract!{callerAddress!() -> 1 alph}(#01, bytecode, encodedFields)
  }

  @using(preapprovedAssets = true)
  pub fn deployWrappedAlph(bytecode: ByteVec, wrappedAlphPoolCodeHash: ByteVec) -> () {
    let encodedFields = encodeToByteVec!(wrappedAlphPoolCodeHash, 0)
    createSubContractWithToken!{callerAddress!() -> 1 alph}(#02, bytecode, encodedFields, 1e9 alph)
  }
}
