import "governance.ral"
import "sequence.ral"
import "token_wrapper.ral"
import "token_interface.ral"
import "token_wrapper.ral"
import "event_emitter.ral"

TxContract TokenBridge(
    governanceId: ByteVec, // governance contract id
    governanceChainId: U256,
    governanceContractId: ByteVec,
    mut next: U256,
    mut next1: U256,
    mut next2: U256,
    mut undoneSequenceId: ByteVec,
    localChainId: U256,
    mut sequence: U256,     // the sequence of next message published by self
    tokenWrapperTemplateId: ByteVec,         // used for create contract by copyCreateContract
    tokenBridgeForChainTemplateId: ByteVec,  // used for create contract by copyCreateContract
    tokenWrapperCodeHash: ByteVec,
    undoneSequenceCodeHash: ByteVec,
    eventEmitterId: ByteVec
) extends Sequence(next, next1, next2, undoneSequenceId, undoneSequenceCodeHash, eventEmitterId) {
    pub fn getGovernanceId() -> (ByteVec) {
        return governanceId
    }

    pub fn getLocalChainId() -> (U256) {
        return localChainId
    }

    pub fn getMessageFee() -> (U256) {
        let governance = Governance(governanceId)
        return governance.getMessageFee()
    }

    fn checkModuleAndAction(payload: ByteVec, start: U256, action: ByteVec) -> () {
        let tokenBridgeModule = #000000000000000000000000000000000000000000546f6b656e427269646765
        assert!(byteVecSlice!(payload, start, start + 32) == tokenBridgeModule)
        assert!(byteVecSlice!(payload, start + 32, start + 33) == action)
    }

    fn verifyGovernanceVAA(vaa: ByteVec) -> (ByteVec) {
        let governance = Governance(governanceId)
        let (emitterChainId, emitterAddress, msgSequence, payload) = governance.parseAndVerifyVAA(vaa)
        assert!(emitterChainId == governanceChainId)
        assert!(emitterAddress == governanceContractId)
        checkSequence(msgSequence)
        return payload
    }

    fn parseRegisterChain(vaa: ByteVec) -> (U256, ByteVec) {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #01)
        let chainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(chainId == localChainId || chainId == 0)
        let remoteChainId = u256From2Byte!(byteVecSlice!(payload, 35, 37))
        assert!(remoteChainId != localChainId)
        let remoteTokenBridgeId = byteVecSlice!(payload, 37, 69)
        assert!(size!(payload) == 69)
        return remoteChainId, remoteTokenBridgeId
    }

    // register chain is a governance action
    @using(preapprovedAssets = true)
    pub fn registerChain(vaa: ByteVec, payer: Address, createContractAlphAmount: U256) -> () {
        let (remoteChainId, remoteTokenBridgeId) = parseRegisterChain(vaa)
        assert!(remoteChainId != localChainId)

        let mut encodedState = encodeToByteVec!(
            governanceId,
            localChainId,
            selfContractId!(),
            remoteChainId,
            remoteTokenBridgeId,
            0,
            0,
            0,
            #,
            tokenWrapperTemplateId,
            tokenWrapperCodeHash,
            undoneSequenceCodeHash,
            eventEmitterId
        )

        approveAlph!(payer, createContractAlphAmount)
        copyCreateSubContract!(u256To2Byte!(remoteChainId), tokenBridgeForChainTemplateId, encodedState)
    }

    pub fn upgradeContract(vaa: ByteVec) -> () {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #02)
        let chainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(chainId == localChainId)
        let contractCodeLength = u256From2Byte!(byteVecSlice!(payload, 35, 37))
        let mut offset = 37 + contractCodeLength
        let newContractCode = byteVecSlice!(payload, 37, offset)
        let payloadLength = size!(payload)
        if (payloadLength == offset) {
            migrate!(newContractCode)
        } else {
            let prevStateHash = byteVecSlice!(payload, offset, offset + 32)
            offset = offset + 32
            let currentEncodedState = u256To32Byte!(next) ++ u256To32Byte!(next1) ++ u256To32Byte!(next2) ++ u256To32Byte!(sequence)
            assert!(prevStateHash == blake2b!(currentEncodedState))
            let stateLength = u256From2Byte!(byteVecSlice!(payload, offset, offset + 2))
            offset = offset + 2
            let newContractState = byteVecSlice!(payload, offset, offset + stateLength)
            offset = offset + stateLength
            assert!(payloadLength == offset)
            migrateWithFields!(newContractCode, newContractState)
        }
    }

    @using(preapprovedAssets = true)
    pub fn attestToken(payer: Address, tokenId: ByteVec, nonce: ByteVec, consistencyLevel: U256) -> () {
        assert!(size!(tokenId) == 32)
        assert!(size!(nonce) == 4)

        let token = ERC20Token(tokenId)
        let symbol = token.symbol()
        let symbolSize = size!(symbol)
        assert!(symbolSize <= 32)
        let name = token.name()
        let nameSize = size!(name)
        assert!(nameSize <= 32)

        let payload = #02 ++ // payloadId
            tokenId ++
            u256To2Byte!(localChainId) ++
            u256To1Byte!(token.decimals()) ++
            zeros!(32 - symbolSize) ++ symbol ++
            zeros!(32 - nameSize) ++ name

        let governance = Governance(governanceId)
        approveAlph!(payer, governance.getMessageFee())
        governance.payMessageFee(payer)
        let eventEmitter = EventEmitter(eventEmitterId)
        eventEmitter.publishWormholeMessage(nextSequence(), nonce, payload, consistencyLevel)
    }

    fn nextSequence() -> (U256) {
        let current = sequence
        sequence = sequence + 1
        return current
    }

    @using(preapprovedAssets = true)
    pub fn publishTransfer(
        payer: Address,
        data: ByteVec,
        nonce: ByteVec,
        consistencyLevel: U256
    ) -> () {
        assert!(callerCodeHash!() == tokenWrapperCodeHash)

        let payload = data ++ callerContractId!()
        let governance = Governance(governanceId)
        approveAlph!(payer, governance.getMessageFee())
        governance.payMessageFee(payer)
        let eventEmitter = EventEmitter(eventEmitterId)
        eventEmitter.publishWormholeMessage(nextSequence(), nonce, payload, consistencyLevel)
    }

    // handle undone sequence transfer message
    @using(preapprovedAssets = true)
    pub fn completeUndoneTransfer(vaa: ByteVec) -> () {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #03)
        let undoneSequence = u256From8Byte!(byteVecSlice!(payload, 33, 41))
        let tokenWrapperId = byteVecSlice!(payload, 41, 73)
        let toAddress = byteVecSlice!(payload, 73, 105)
        let amount = u256From32Byte!(byteVecSlice!(payload, 105, 137))
        let arbiterFee = u256From32Byte!(byteVecSlice!(payload, 137, 169))
        assert!(size!(payload) == 169)
        approveAlph!(uniqueTxInputAddress!(), 1000000000000) // dustAmount

        let tokenWrapper = TokenWrapper(tokenWrapperId)
        tokenWrapper.completeUndoneTransfer(toAddress, amount, arbiterFee)
        let eventEmitter = EventEmitter(eventEmitterId)
        eventEmitter.publishUndoneSequenceCompleted(tokenWrapper.getRemoteChainId(), undoneSequence)
    }
}
