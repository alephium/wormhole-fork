import "undone_sequence.ral"
import "init_undone_sequence_interface.ral"
import "event_emitter.ral"

// sequence started from 0, set `next = 0` when init contract state
TxContract Sequence(
    mut next: U256,
    mut next1: U256, // TODO: better name
    mut next2: U256,
    mut undoneSequenceId: ByteVec,
    undoneSequenceCodeHash: ByteVec,
    eventEmitterId: ByteVec
) implements InitUndoneSequence {
    fn initialized() -> Bool {
        return undoneSequenceId != #
    }

    pub fn init(contractId: ByteVec) -> () {
        assert!(!initialized())
        undoneSequenceId = contractId
        let undoneSequence = UndoneSequence(contractId)
        assert!(undoneSequence.getUndoneList() == #)
        assert!(undoneSequence.getOwner() == selfContractId!())
        assert!(contractCodeHash!(contractId) == undoneSequenceCodeHash)
    }

    pub fn getNext() -> U256 {
        return next 
    }

    pub fn getNext1() -> U256 {
        return next1
    }

    pub fn getNext2() -> U256 {
        return next2
    }

    fn compact(seq: U256) -> () {
        if (next1 != 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {
            let undoneSequence = UndoneSequence(undoneSequenceId)
            let removed = undoneSequence.addToUndone(next, seq, next1)
            if (removed != #) {
                let eventEmitter = EventEmitter(eventEmitterId)
                eventEmitter.publishUndoneSequenceRemoved(removed)
            }
        }
        next = next + 256
        next1 = next2
        next2 = 0
    }

    fn setExecuted(offset: U256, current: U256) -> U256 {
        let flag = 1 << offset
        assert!(current & flag == 0)
        return current | flag
    }

    fn checkSequence(seq: U256) -> () {
        assert!(initialized())
        if (seq < next) {
            let undoneSequence = UndoneSequence(undoneSequenceId)
            assert!(undoneSequence.trySetDone(seq))
            return
        }

        if (seq >= (next + 512)) {
            compact(seq)
        }

        assert!(seq < (next + 512))
        let offset = seq - next
        if (offset < 256) {
            next1 = setExecuted(offset, next1)
        } else {
            next2 = setExecuted(offset - 256, next2)
        }
    }
}
