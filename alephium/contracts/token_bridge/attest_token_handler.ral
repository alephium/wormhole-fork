Contract AttestTokenHandler(
  governance: Governance,
  localTokenBridge: TokenBridge,
  remoteChainId: U256,
  remoteTokenBridgeId: ByteVec,
  mut receivedSequence: U256
) extends Constants(), TokenBridgeConstants() {
  fn parseAttestToken(vaa: ByteVec) -> (ByteVec, ByteVec, ByteVec, U256, U256) {
    let (emitterChainId, targetChainId, emitterAddress, msgSequence, payload) = governance.parseAndVerifyVAA(vaa, false)
    assert!(emitterChainId == remoteChainId, ErrorCodes.InvalidEmitChainId)
    assert!(emitterAddress == remoteTokenBridgeId, ErrorCodes.InvalidEmitAddress)
    assert!(targetChainId == 0, ErrorCodes.InvalidTargetChainId)
    assert!(msgSequence >= receivedSequence, ErrorCodes.InvalidSequence)
    receivedSequence = msgSequence + 1

    assert!(byteVecSlice!(payload, 0, 1) == PayloadId.AttestToken, ErrorCodes.InvalidPayloadId)
    let tokenId = byteVecSlice!(payload, 1, 33)
    let tokenChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
    assert!(tokenChainId == remoteChainId, ErrorCodes.InvalidAttestTokenMessage)
    let decimals = u256From1Byte!(byteVecSlice!(payload, 35, 36))
    let symbol = byteVecSlice!(payload, 36, 68)
    let name = byteVecSlice!(payload, 68, 100)
    assert!(size!(payload) == 100, ErrorCodes.InvalidMessageSize)
    return tokenId, symbol, name, decimals, msgSequence
  }

  @using(preapprovedAssets = true)
  pub fn createRemoteTokenPool(
    vaa: ByteVec,
    payer: Address,
    createContractAlphAmount: U256
  ) -> () {
    let (tokenId, symbol, name, decimals, msgSequence) = parseAttestToken(vaa)
    localTokenBridge.createRemoteTokenPool{payer -> createContractAlphAmount}(
      tokenId, remoteChainId, decimals, symbol, name, msgSequence, payer, createContractAlphAmount
    )
  }

  pub fn updateRemoteTokenPool(vaa: ByteVec) -> () {
    let (tokenId, symbol, name, _, msgSequence) = parseAttestToken(vaa)
    localTokenBridge.updateRemoteTokenPool(tokenId, remoteChainId, symbol, name, msgSequence)
  }
}
