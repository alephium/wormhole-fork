Contract TokenBridge(
    governance: Governance,
    localChainId: U256,
    mut receivedSequence: U256,
    mut sendSequence: U256,     // the sequence of next message published by self
    wrappedAlphId: ByteVec,
    tokenBridgeFactory: TokenBridgeFactory,
    mut minimalConsistencyLevel: U256,
    mut refundAddress: Address
) extends TokenBridgeGovernance(governance, localChainId, receivedSequence, sendSequence, tokenBridgeFactory, minimalConsistencyLevel, refundAddress) {
    @using(preapprovedAssets = true)
    pub fn attestToken(payer: Address, localTokenId: ByteVec, nonce: ByteVec, consistencyLevel: U256) -> () {
        assert!(size!(localTokenId) == 32, ErrorCodes.InvalidTokenId)
        assert!(size!(nonce) == 4, ErrorCodes.InvalidNonceSize)
        if (localTokenId != wrappedAlphId) {
            assert!(tokenRemaining!(payer, localTokenId) > 0, ErrorCodes.TokenNotExist) // make sure that the token exists
        }

        // We don't set decimals, symbol and name for local token due to sharding
        let payload = PayloadId.AttestToken ++
            localTokenId ++
            u256To2Byte!(localChainId) ++
            #00 ++  // zero decimals
            zeros!(32) ++ // no symbol
            zeros!(32) // no name

        governance.publishWormholeMessage{payer -> governance.getMessageFee()}(payer, 0, nextSendSequence(), nonce, payload, consistencyLevel)
    }

    fn nextSendSequence() -> (U256) {
        let current = sendSequence
        sendSequence = sendSequence + 1
        return current
    }

    @using(preapprovedAssets = true)
    pub fn createLocalTokenPool(localTokenId: ByteVec, payer: Address, createContractAlphAmount: U256) -> () {
        let isWrappedAlph = localTokenId == wrappedAlphId
        if (!isWrappedAlph) {
            assert!(tokenRemaining!(payer, localTokenId) > 0, ErrorCodes.TokenNotExist) // make sure that the token exists
        }
        let encodedFields = encodeToByteVec!(
            selfContractId!(),
            localChainId,
            localTokenId,
            0,
            0
        )
        let path = Path.TokenPool ++ u256To2Byte!(localChainId) ++ localTokenId
        let templateContractId =
            if (isWrappedAlph) tokenBridgeFactory.getWrappedAlphPoolTemplateId()
            else tokenBridgeFactory.getLocalTokenPoolTemplateId()
        copyCreateSubContract!{payer -> createContractAlphAmount}(
            path,
            templateContractId,
            encodedFields
        )
    }

    @using(preapprovedAssets = true)
    pub fn createRemoteTokenPool(
        bridgeTokenId: ByteVec,
        tokenChainId: U256,
        decimals: U256,
        symbol: ByteVec,
        name: ByteVec,
        msgSequence: U256,
        payer: Address,
        createContractAlphAmount: U256
    ) -> () {
        let expectedCaller = subContractId!(Path.AttestTokenHandler ++ u256To2Byte!(tokenChainId))
        checkCaller!(callerContractId!() == expectedCaller, ErrorCodes.InvalidCaller)
        let encodedFields = encodeToByteVec!(
            selfContractId!(),
            tokenChainId,
            bridgeTokenId,
            0,
            symbol,
            name,
            decimals,
            msgSequence
        )
        let path = Path.TokenPool ++ u256To2Byte!(tokenChainId) ++ bridgeTokenId
        let tokenAmount = 1 << 255 // save some space from 0xff...ff
        copyCreateSubContractWithToken!{payer -> createContractAlphAmount}(
            path,
            tokenBridgeFactory.getRemoteTokenPoolTemplateId(),
            encodedFields,
            tokenAmount
        )
    }

    pub fn updateRemoteTokenPool(
        bridgeTokenId: ByteVec,
        tokenChainId: U256,
        symbol: ByteVec,
        name: ByteVec,
        msgSequence: U256
    ) -> () {
        let expectedCaller = subContractId!(Path.AttestTokenHandler ++ u256To2Byte!(tokenChainId))
        checkCaller!(callerContractId!() == expectedCaller, ErrorCodes.InvalidCaller)
        let path = Path.TokenPool ++ u256To2Byte!(tokenChainId) ++ bridgeTokenId
        let remoteTokenPool = RemoteTokenPool(subContractId!(path))
        remoteTokenPool.updateDetails(symbol, name, msgSequence)
    }

    @using(preapprovedAssets = true)
    pub fn transferToken(
        fromAddress: Address,
        bridgeTokenId: ByteVec,
        tokenChainId: U256,
        toChainId: U256,
        toAddress: ByteVec,
        tokenAmount: U256,
        arbiterFee: U256,
        nonce: ByteVec,
        consistencyLevel: U256
    ) -> () {
        assert!(consistencyLevel >= minimalConsistencyLevel, ErrorCodes.InvalidConsistencyLevel)
        assert!(toChainId != localChainId, ErrorCodes.InvalidTransferTargetChain)
        let isLocalToken = tokenChainId == localChainId
        let tokenPoolId = subContractId!(Path.TokenPool ++ u256To2Byte!(tokenChainId) ++ bridgeTokenId)
        let messageFee = governance.getMessageFee()
        let payload =
            if (bridgeTokenId == wrappedAlphId) WrappedAlphPool(tokenPoolId).transfer{fromAddress -> tokenAmount}(fromAddress, toAddress, tokenAmount, messageFee, arbiterFee, nonce)
            else if (isLocalToken) LocalTokenPool(tokenPoolId).transfer{fromAddress -> bridgeTokenId: tokenAmount}(fromAddress, toAddress, tokenAmount, arbiterFee, nonce)
            else RemoteTokenPool(tokenPoolId).transfer{fromAddress -> tokenPoolId: tokenAmount}(fromAddress, toAddress, tokenAmount, arbiterFee, nonce)

        let tokenBridgeForChainId = subContractId!(Path.TokenBridgeForChain ++ u256To2Byte!(toChainId))
        let tokenBridgeForChain = TokenBridgeForChain(tokenBridgeForChainId)
        governance.publishWormholeMessage{fromAddress -> messageFee}(
            fromAddress, toChainId, tokenBridgeForChain.nextSendSequence(), nonce, payload, consistencyLevel
        )
    }

    @using(preapprovedAssets = true)
    pub fn transferAlph(
        fromAddress: Address,
        toChainId: U256,
        toAddress: ByteVec,
        alphAmount: U256,
        arbiterFee: U256,
        nonce: ByteVec,
        consistencyLevel: U256
    ) -> () {
        transferToken{fromAddress -> alphAmount}(fromAddress, wrappedAlphId, localChainId, toChainId, toAddress, alphAmount, arbiterFee, nonce, consistencyLevel)
    }
}
