Contract WrappedAlph(
    wrappedAlphPoolCodeHash: ByteVec,
    mut totalWrapped: U256
) extends Constants() {
    @using(preapprovedAssets=true, assetsInContract=true)
    pub fn wrapAndTransfer(
        fromAddress: Address,
        totalAmount: U256
    ) -> () {
        checkCaller!(callerCodeHash!() == wrappedAlphPoolCodeHash, ErrorCodes.InvalidCaller)
        totalWrapped = totalWrapped + totalAmount
        transferAlphToSelf!(fromAddress, totalAmount)
        let self = selfAddress!()
        WrappedAlphPool(callerContractId!()).receiveWrappedAlph{
            self -> selfTokenId!(): totalAmount
        }(self, totalAmount)
    }

    @using(preapprovedAssets=true, assetsInContract=true)
    pub fn unwrapAndCompleteTransfer(
        fromAddress: Address,
        recipient: Address,
        transferAmount: U256,
        arbiter: Address,
        arbiterFee: U256
    ) -> () {
        checkCaller!(callerCodeHash!() == wrappedAlphPoolCodeHash, ErrorCodes.InvalidCaller)
        let totalAmount = transferAmount + arbiterFee
        totalWrapped = totalWrapped - totalAmount

        transferTokenToSelf!(fromAddress, selfTokenId!(), totalAmount)
        transferAlphFromSelf!(recipient, transferAmount)
        if (arbiterFee > 0) {
            transferAlphFromSelf!(arbiter, arbiterFee)
        }
    }
}
