Contract WrappedAlphPool(
    tokenBridgeId: ByteVec,
    tokenChainId: U256, // local chain id
    bridgeTokenId: ByteVec, // wrapped ALPH id
    mut totalBridged: U256,
    decimals_: U256 // should be 0
) extends BridgeTokenPool(tokenBridgeId, tokenChainId, bridgeTokenId, totalBridged, decimals_) {
    @using(preapprovedAssets = true)
    pub fn transfer(
        fromAddress: Address,
        toAddress: ByteVec,
        amount: U256,
        arbiterFee: U256,
        nonce: ByteVec
    ) -> ByteVec {
        let (payload, totalAmount) = prepareTransfer(callerContractId!(), toAddress, amount, arbiterFee, nonce)

        WrappedAlph(bridgeTokenId).wrapAndTransfer{
            fromAddress -> totalAmount
        }(fromAddress, totalAmount)
        totalBridged = totalBridged + totalAmount

        return payload
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn receiveWrappedAlph(fromAddress: Address, totalAmount: U256) -> () {
        checkCaller!(callerContractId!() == bridgeTokenId, ErrorCodes.InvalidCaller)
        transferTokenToSelf!(fromAddress, bridgeTokenId, totalAmount)
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn completeTransfer(
        emitterChainId: U256,
        amount: U256,
        vaaTokenId: ByteVec,
        vaaTokenChainId: U256,
        recipient: Address,
        normalizedArbiterFee: U256,
        caller: Address
    ) -> () {
        let (transferAmount, arbiterFee) = prepareCompleteTransfer(
            callerContractId!(), emitterChainId, amount, vaaTokenId, vaaTokenChainId, normalizedArbiterFee
        )

        if (caller != recipient) {
            transferAlph!(caller, recipient, dustAmount!())
        }
        let self = selfAddress!()
        WrappedAlph(bridgeTokenId).unwrapAndCompleteTransfer{
            self -> bridgeTokenId: transferAmount + arbiterFee
        }(self, recipient, transferAmount, caller, arbiterFee)
        totalBridged = totalBridged - transferAmount - arbiterFee
    }
}
