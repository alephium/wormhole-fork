Contract RemoteTokenPool(
    tokenBridgeId: ByteVec,
    tokenChainId: U256, // remote token chain id
    bridgeTokenId: ByteVec, // remote token id
    mut totalBridged: U256,
    symbol_: ByteVec,
    name_: ByteVec,
    decimals_: U256
) extends BridgeTokenPool(tokenBridgeId, tokenChainId, bridgeTokenId, totalBridged, decimals_) {
    @using(readonly = true)
    pub fn name() -> ByteVec {
        return name_
    }

    @using(readonly = true)
    pub fn symbol() -> ByteVec {
        return symbol_
    }

    @using(readonly = true)
    pub fn decimals() -> U256 {
        return decimals_
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn transfer(
        fromAddress: Address,
        toAddress: ByteVec,
        amount: U256,
        arbiterFee: U256,
        nonce: ByteVec
    ) -> ByteVec {
        let (payload, totalAmount) = prepareTransfer(callerContractId!(), toAddress, amount, arbiterFee, nonce)

        transferTokenToSelf!(fromAddress, selfTokenId!(), totalAmount)
        totalBridged = totalBridged - totalAmount

        return payload
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn completeTransfer(
        emitterChainId: U256,
        amount: U256,
        vaaTokenId: ByteVec,
        vaaTokenChainId: U256,
        recipient: Address,
        normalizedArbiterFee: U256,
        caller: Address
    ) -> () {
        let (transferAmount, arbiterFee) = prepareCompleteTransfer(
            callerContractId!(), emitterChainId, amount, vaaTokenId, vaaTokenChainId, normalizedArbiterFee
        )

        if (caller != recipient) {
            transferAlph!(caller, recipient, dustAmount!())
        }
        let tokenId = selfTokenId!()
        transferTokenFromSelf!(recipient, tokenId, transferAmount)
        if (arbiterFee > 0) {
            transferTokenFromSelf!(caller, tokenId, arbiterFee)
        }
        totalBridged = totalBridged + transferAmount + arbiterFee
    }
}
