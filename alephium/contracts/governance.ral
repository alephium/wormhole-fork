import "sequence.ral"

TxContract Governance(
    chainId: U256,
    governanceChainId: U256,
    governanceContract: ByteVec,
    mut receivedSequence: U256,
    mut messageFee: U256,
    mut guardianSets: [[ByteVec; 19]; 2], // keep previous and current guardian set
    mut guardianSetIndexes: [U256; 2],
    mut guardianSetSizes: [U256; 2],
    mut previousGuardianSetExpirationTime: U256
) {

    event WormholeMessage(sender: ByteVec, sequence: U256, nonce: ByteVec, payload: ByteVec, consistencyLevel: U256)

    pub fn getMessageFee() -> (U256) {
        return messageFee
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn publishWormholeMessage(
        payer: Address,
        sequence: U256,
        nonce: ByteVec,
        payload: ByteVec,
        consistencyLevel: U256
    ) -> () {
        transferAlphToSelf!(payer, messageFee)
        emit WormholeMessage(callerContractId!(), sequence, nonce, payload, consistencyLevel)
    }

    // return emitterChainId, emitterAddress, sequence, payload
    pub fn parseBody(body: ByteVec) -> (U256, ByteVec, U256, ByteVec) {
        let timestamp = u256From4Byte!(byteVecSlice!(body, 0, 4))
        let nonce = u256From4Byte!(byteVecSlice!(body, 4, 8))
        let emitterChainId = u256From2Byte!(byteVecSlice!(body, 8, 10))
        let emitterAddress = byteVecSlice!(body, 10, 42)
        let sequence = u256From8Byte!(byteVecSlice!(body, 42, 50))
        let consistencyLevel = u256From1Byte!(byteVecSlice!(body, 50, 51))
        let payload = byteVecSlice!(body, 51, size!(body))
        return emitterChainId, emitterAddress, sequence, payload
    }

    fn verifyGovernanceVAA(vaa: ByteVec) -> ByteVec {
        let body = parseAndVerifySignatures(vaa, true)
        let (emitterChainId, emitterAddress, msgSequence, payload) = parseBody(body)
        assert!(emitterChainId == governanceChainId)
        assert!(emitterAddress == governanceContract)
        assert!(msgSequence == receivedSequence)
        receivedSequence = receivedSequence + 1
        return payload
    }

    pub fn parseAndVerifyVAA(vaa: ByteVec) -> (U256, ByteVec, U256, ByteVec) {
        let body = parseAndVerifySignatures(vaa, false)
        return parseBody(body)
    }

    // parse VAA and verify signatures, return body
    fn parseAndVerifySignatures(data: ByteVec, checkGuardianSetIndex: Bool) -> (ByteVec) {
        assert!(byteVecSlice!(data, 0, 1) == #01)
        let guardianSetIndex = u256From4Byte!(byteVecSlice!(data, 1, 5))
        if (checkGuardianSetIndex) {
            assert!(guardianSetIndex == guardianSetIndexes[1])
        }

        let signatureSize = u256From1Byte!(byteVecSlice!(data, 5, 6))
        assert!(signatureSize <= 19)
        let (keys, expirationTime, guardianSize) = getGuardiansInfo(guardianSetIndex)
        assert!((guardianSetIndex == guardianSetIndexes[1]) || (blockTimeStamp!() <= expirationTime))

        // check signature quorum size
        assert!((guardianSize * 10 / 3) * 2 / 10 + 1 <= signatureSize)

        let mut offset = 6
        let body = byteVecSlice!(data, 6 + signatureSize * 66, size!(data))
        let hash = keccak256!(keccak256!(body))

        let mut lastGuardianIndex = 0
        let mut sigIndex = 0
        while (sigIndex < signatureSize) {
            // 1 byte `guardianIndex` and 65 bytes signature
            let guardianIndex = u256From1Byte!(byteVecSlice!(data, offset, offset + 1))
            assert!(sigIndex == 0 || guardianIndex > lastGuardianIndex)

            let signature = byteVecSlice!(data, offset + 1, offset + 66)
            let recId = u256From1Byte!(byteVecSlice!(signature, 64, 65)) + 27
            let newSignature = byteVecSlice!(signature, 0, 64) ++ u256To1Byte!(recId)
            assert!(keys[guardianIndex] == ethEcRecover!(hash, newSignature))
            lastGuardianIndex = guardianIndex

            offset = offset + 66
            sigIndex = sigIndex + 1
        }
        return body
    }

    fn getGuardiansInfo(guardianSetIndex: U256) -> ([ByteVec; 19], U256, U256) {
        if (guardianSetIndex == guardianSetIndexes[1]) {
            return guardianSets[1], 0, guardianSetSizes[1]
        }
        if (guardianSetIndex == guardianSetIndexes[0]) {
            return guardianSets[0], previousGuardianSetExpirationTime, guardianSetSizes[0]
        }
        assert!(false) // invalid guardian set index
        return [#; 19], 0, 0
    }

    fn checkModuleAndAction(payload: ByteVec, start: U256, action: ByteVec) -> () {
        let coreModule = #00000000000000000000000000000000000000000000000000000000436f7265
        assert!(byteVecSlice!(payload, start, start + 32) == coreModule)
        assert!(byteVecSlice!(payload, start + 32, start + 33) == action)
    }

    fn updatePreviousGuardianSet() -> () {
        guardianSets[0] = guardianSets[1]
        guardianSetIndexes[0] = guardianSetIndexes[1]
        guardianSetSizes[0] = guardianSetSizes[1]
        previousGuardianSetExpirationTime = blockTimeStamp!() + 86400000 // expired after one day
    }

    pub fn updateGuardianSet(vaa: ByteVec) -> () {
        updatePreviousGuardianSet()
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #02)
        let vaaChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(vaaChainId == chainId || vaaChainId == 0)
        let newGuardianSetIndex = u256From4Byte!(byteVecSlice!(payload, 35, 39))
        assert!(newGuardianSetIndex == guardianSetIndexes[1] + 1)
        let newGuardianSetSize = u256From1Byte!(byteVecSlice!(payload, 39, 40))
        assert!(newGuardianSetSize > 0 && newGuardianSetSize <= 19)
        let mut offset = 40
        let mut guardianIndex = 0
        while (guardianIndex < 19) {
            if (guardianIndex < newGuardianSetSize) {
                guardianSets[1][guardianIndex] = byteVecSlice!(payload, offset, offset + 20)
                offset = offset + 20
            } else {
                guardianSets[1][guardianIndex] = #
            }
            guardianIndex = guardianIndex + 1
        }
        assert!(size!(payload) == offset)
        guardianSetIndexes[1] = newGuardianSetIndex
        guardianSetSizes[1] = newGuardianSetSize
    }

    pub fn setMessageFee(vaa: ByteVec) -> () {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #03)
        let vaaChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(vaaChainId == chainId)
        let fee = u256From32Byte!(byteVecSlice!(payload, 35, 67))
        assert!(size!(payload) == 67)
        messageFee = fee
    }

    @using(assetsInContract = true)
    pub fn submitTransferFee(vaa: ByteVec) -> () {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #04)
        let vaaChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(vaaChainId == chainId || vaaChainId == 0)
        let amount = u256From32Byte!(byteVecSlice!(payload, 35, 67))
        let recipient = byteVecSlice!(payload, 67, 99)
        assert!(size!(payload) == 99)
        transferAlphFromSelf!(byteVecToAddress!(#00 ++ recipient), amount)
    }

    pub fn upgradeContract(vaa: ByteVec) -> () {
        let payload = verifyGovernanceVAA(vaa)
        checkModuleAndAction(payload, 0, #01)
        let vaaChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
        assert!(vaaChainId == chainId)
        let contractCodeLength = u256From2Byte!(byteVecSlice!(payload, 35, 37))
        let mut offset = 37 + contractCodeLength
        let newContractCode = byteVecSlice!(payload, 37, offset)
        let payloadLength = size!(payload)
        if (payloadLength == offset) {
            migrate!(newContractCode)
        } else {
            let prevStateHash = byteVecSlice!(payload, offset, offset + 32)
            offset = offset + 32
            let currentEncodedState = u256To32Byte!(receivedSequence)
                ++ u256To32Byte!(messageFee)
                ++ u256To32Byte!(guardianSetIndexes[0])
                ++ u256To32Byte!(guardianSetIndexes[1])
            assert!(prevStateHash == blake2b!(currentEncodedState))
            let stateLength = u256From2Byte!(byteVecSlice!(payload, offset, offset + 2))
            offset = offset + 2
            let newContractState = byteVecSlice!(payload, offset, offset + stateLength)
            offset = offset + stateLength
            assert!(payloadLength == offset)
            migrateWithFields!(newContractCode, newContractState)
        }
    }
}
