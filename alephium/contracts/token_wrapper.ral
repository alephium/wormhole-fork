import "token_bridge.ral"
import "token_bridge_for_chain.ral"
import "math.ral"
import "constants.ral"
import "token_bridge_constants.ral"

TxContract TokenWrapper(
    tokenBridgeId: ByteVec,
    tokenBridgeForChainId: ByteVec,
    localChainId: U256,
    remoteChainId: U256,
    bridgeTokenId: ByteVec, // either local token id or remote token id
    isLocalToken: Bool,
    symbol_: ByteVec,
    name_: ByteVec,
    decimals_: U256
) extends Math(), Constants(), TokenBridgeConstants() {
    pub fn name() -> ByteVec {
        assert!(!isLocalToken) // unknown for local token
        return name_
    }

    pub fn symbol() -> ByteVec {
        assert!(!isLocalToken) // unknown for local token
        return symbol_
    }

    pub fn decimals() -> U256 {
        assert!(!isLocalToken) // unknown for local token
        return decimals_
    }

    fn getTokenId() -> ByteVec {
        if (isLocalToken) {
            return bridgeTokenId
        } else {
            return selfContractId!()
        }
    }

    fn getTokenChainId() -> U256 {
        if (isLocalToken) {
            return localChainId
        } else {
            return remoteChainId
        }
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn transfer(
        fromAddress: Address,
        toAddress: ByteVec,
        amount: U256,
        arbiterFee: U256,
        nonce: ByteVec
    ) -> ByteVec {
        assertWithErrorCode!(callerContractId!() == tokenBridgeId, ErrorCodes.InvalidCaller)
        assertWithErrorCode!(size!(toAddress) == 32, ErrorCodes.InvalidTransferToAddress)
        assertWithErrorCode!(size!(nonce) == 4, ErrorCodes.InvalidNonceSize)

        let normalizedAmount = if (isLocalToken) amount else normalizeAmount(amount, decimals_)
        let normalizedFee = if (isLocalToken) arbiterFee else normalizeAmount(arbiterFee, decimals_)
        assertWithErrorCode!(normalizedFee < normalizedAmount, ErrorCodes.TransferFeeLessThanAmount)

        let transferAmount = deNormalizeAmount(normalizedAmount, decimals_)
        transferTokenToSelf!(fromAddress, getTokenId(), transferAmount)

        let tokenChainId = getTokenChainId()
        return PayloadId.Transfer ++
            u256To32Byte!(normalizedAmount) ++
            bridgeTokenId ++
            u256To2Byte!(tokenChainId) ++
            toAddress ++
            u256To32Byte!(normalizedFee)
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn completeTransfer(vaa: ByteVec, caller: Address) -> () {
        let tokenBridgeForChain = TokenBridgeForChain(tokenBridgeForChainId)
        let (sequenceReady, payload) = tokenBridgeForChain.checkTransfer(vaa)
        if (!sequenceReady) { // too many undone sequences in between, compact those sequences first
            return
        }

        assertWithErrorCode!(byteVecSlice!(payload, 0, 1) == PayloadId.Transfer, ErrorCodes.InvalidPayloadId)
        let amount = u256From32Byte!(byteVecSlice!(payload, 1, 33))
        let originalTokenId = byteVecSlice!(payload, 33, 65)
        let tokenChainId = u256From2Byte!(byteVecSlice!(payload, 65, 67))
        let toAddress = byteVecSlice!(payload, 67, 99)
        let arbiterFee = u256From32Byte!(byteVecSlice!(payload, 99, 131))
        assertWithErrorCode!(size!(payload) == 131, ErrorCodes.InvalidMessageSize)
        assertWithErrorCode!(originalTokenId == bridgeTokenId, ErrorCodes.InvalidTransferMessage)
        assertWithErrorCode!(tokenChainId == getTokenChainId(), ErrorCodes.InvalidTransferMessage)

        let totalAmount = deNormalizeAmount(amount, decimals_)
        let transferFee = deNormalizeAmount(arbiterFee, decimals_)
        assertWithErrorCode!(totalAmount > transferFee, ErrorCodes.TransferFeeLessThanAmount)
        let transferAmount = totalAmount - transferFee
        let recipient = byteVecToAddress!(#00 ++ toAddress)
        let tokenId = getTokenId()
        if (caller != recipient) {
            transferAlph!(caller, recipient, dustAmount!())
        }
        transferTokenFromSelf!(recipient, tokenId, transferAmount)
        if (transferFee > 0) {
            transferTokenFromSelf!(caller, tokenId, transferFee)
        }
    }
}
