import "token_bridge.ral"
import "token_bridge_for_chain.ral"
import "token_interface.ral"
import "math.ral"

TxContract TokenWrapper(
    tokenBridgeId: ByteVec,
    tokenBridgeForChainId: ByteVec,
    localChainId: U256,
    remoteChainId: U256,
    bridgeTokenId: ByteVec, // either local token id or remote token id
    isLocalToken: Bool,
    symbol_: ByteVec,
    name_: ByteVec,
    decimals_: U256
) extends Math() {
    pub fn name() -> ByteVec {
        assert!(!isLocalToken) // unknown for local token
        return name_
    }

    pub fn symbol() -> ByteVec {
        assert!(!isLocalToken) // unknown for local token
        return symbol_
    }

    pub fn decimals() -> U256 {
        assert!(!isLocalToken) // unknown for local token
        return decimals_
    }

    fn getTokenId() -> ByteVec {
        if (isLocalToken) {
            return bridgeTokenId
        } else {
            return selfContractId!()
        }
    }

    fn getTokenChainId() -> U256 {
        if (isLocalToken) {
            return localChainId
        } else {
            return remoteChainId
        }
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn transfer(
        fromAddress: Address,
        toAddress: ByteVec,
        amount: U256,
        arbiterFee: U256,
        nonce: ByteVec,
        consistencyLevel: U256
    ) -> ByteVec {
        assert!(callerContractId!() == tokenBridgeId)
        assert!(size!(toAddress) == 32)
        assert!(size!(nonce) == 4)

        let normalizedAmount = if (isLocalToken) amount else normalizeAmount(amount, decimals_)
        let normalizedFee = if (isLocalToken) arbiterFee else normalizeAmount(arbiterFee, decimals_)
        assert!(normalizedFee < normalizedAmount)

        let transferAmount = deNormalizeAmount(normalizedAmount, decimals_)
        transferTokenToSelf!(fromAddress, getTokenId(), transferAmount)

        let tokenChainId = getTokenChainId()
        return #01 ++ // payloadId
            u256To32Byte!(normalizedAmount) ++
            bridgeTokenId ++
            u256To2Byte!(tokenChainId) ++
            toAddress ++
            u256To32Byte!(normalizedFee)
    }

    @using(preapprovedAssets = true, assetsInContract = true)
    pub fn completeTransfer(vaa: ByteVec, caller: Address) -> () {
        let tokenBridgeForChain = TokenBridgeForChain(tokenBridgeForChainId)
        let (sequenceReady, payload) = tokenBridgeForChain.checkTransfer(vaa)
        if (!sequenceReady) { // too many undone sequences in between, compact those sequences first
            return
        }

        assert!(byteVecSlice!(payload, 0, 1) == #01) // payloadId
        let amount = u256From32Byte!(byteVecSlice!(payload, 1, 33))
        let originalTokenId = byteVecSlice!(payload, 33, 65)
        let tokenChainId = u256From2Byte!(byteVecSlice!(payload, 65, 67))
        let toAddress = byteVecSlice!(payload, 67, 99)
        let arbiterFee = u256From32Byte!(byteVecSlice!(payload, 99, 131))
        assert!(size!(payload) == 131)
        assert!(originalTokenId == bridgeTokenId)
        assert!(tokenChainId == getTokenChainId())

        let totalAmount = deNormalizeAmount(amount, decimals_)
        let transferFee = deNormalizeAmount(arbiterFee, decimals_)
        assert!(totalAmount > transferFee)
        let transferAmount = totalAmount - transferFee
        let recipient = byteVecToAddress!(#00 ++ toAddress)
        let tokenId = getTokenId()
        transferAlph!(caller, recipient, dustAmount!())
        transferTokenFromSelf!(recipient, tokenId, transferAmount)
        if (transferFee > 0) {
            transferTokenFromSelf!(caller, tokenId, transferFee)
        }
    }
}
