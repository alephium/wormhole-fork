import "governance.ral"
import "token_interface.ral"
import "math.ral"
import "sequence.ral"
import "undone_sequence.ral"

TxContract TokenBridgeForChain(
    governanceContractId: ByteVec,
    localChainId: U256,
    localTokenBridgeId: ByteVec, // local chain token bridge contract id
    remoteChainId: U256,
    remoteTokenBridgeId: ByteVec, // remote chain token bridge contract id
    mut next: U256,
    mut next1: U256,
    mut next2: U256,
    undoneSequenceTemplateId: ByteVec,
    tokenWrapperTemplateId: ByteVec, // used for create contract by copyCreateContract
    refundAddress: Address,
    mut sendSequence: U256
) extends Sequence(next, next1, next2, undoneSequenceTemplateId, refundAddress) {
    @using(preapprovedAssets = true)
    pub fn createWrapperForLocalToken(tokenId: ByteVec, payer: Address, createContractAlphAmount: U256) -> () {
        let token = ERC20Token(tokenId)
        let symbol = token.symbol()
        let symbolSize = size!(symbol)
        assert!(symbolSize <= 32)
        let name = token.name()
        let nameSize = size!(name)
        assert!(nameSize <= 32)

        let encodedState = encodeToByteVec!(
            localTokenBridgeId,
            selfContractId!(),
            localChainId,
            remoteChainId,
            tokenId,
            true,
            zeros!(32 - symbolSize) ++ symbol,
            zeros!(32 - nameSize) ++ name,
            token.decimals()
        )
        copyCreateSubContract!{payer -> createContractAlphAmount}(tokenId, tokenWrapperTemplateId, encodedState)
    }

    @using(preapprovedAssets = true)
    pub fn createWrapperForRemoteToken(
        tokenId: ByteVec,
        decimals: U256,
        symbol: ByteVec,
        name: ByteVec,
        payer: Address,
        createContractAlphAmount: U256
    ) -> () {
        let path = #00 ++ u256To2Byte!(remoteChainId) ++ localTokenBridgeId
        let expectedCaller = blake2b!(blake2b!(path))
        assert!(callerContractId!() == expectedCaller)
        let encodedState = encodeToByteVec!(
            localTokenBridgeId,
            selfContractId!(),
            localChainId,
            remoteChainId,
            tokenId,
            false,
            symbol,
            name,
            decimals
        )
        let tokenAmount = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
        copyCreateSubContractWithToken!{payer -> createContractAlphAmount}(tokenId, tokenWrapperTemplateId, encodedState, tokenAmount)
    }

    pub fn nextSendSequence() -> U256 {
        assert!(callerContractId!() == localTokenBridgeId)
        let msgSequence = sendSequence
        sendSequence = sendSequence + 1
        return msgSequence
    }

    pub fn checkTransfer(vaa: ByteVec) -> (Bool, ByteVec) {
        let governance = Governance(governanceContractId)
        let (emitterChainId, targetChainId, emitterAddress, msgSequence, payload) = governance.parseAndVerifyVAA(vaa)
        assert!(emitterChainId == remoteChainId)
        assert!(emitterAddress == remoteTokenBridgeId)
        assert!(targetChainId == localChainId)

        let tokenId = byteVecSlice!(payload, 33, 65)
        assert!(callerContractId!() == subContractId!(tokenId))
        return checkSequence(msgSequence), payload
    }

    pub fn destroyUndoneSequenceContracts(paths: ByteVec) -> () {
        assert!(callerContractId!() == localTokenBridgeId)
        let length = size!(paths)
        let mut index = 0
        while (index < length) {
            let undoneSequenceId = subContractId!(byteVecSlice!(paths, index, index + 8))
            UndoneSequence(undoneSequenceId).destroy()
            index = index + 8
        }
    }
}
