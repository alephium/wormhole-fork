import "token_bridge_for_chain.ral"
import "governance.ral"

TxContract AttestTokenHandler(
  governanceContractId: ByteVec,
  localChainId: U256,
  localTokenBridgeId: ByteVec,
  remoteChainId: U256,
  remoteTokenBridgeId: ByteVec,
  mut receivedSequence: U256
) {
  @using(preapprovedAssets = true)
  pub fn handleAttestToken(
    vaa: ByteVec,
    payer: Address,
    createContractAlphAmount: U256
  ) -> () {
    let governance = Governance(governanceContractId)
    let (emitterChainId, targetChainId, emitterAddress, msgSequence, payload) = governance.parseAndVerifyVAA(vaa)
    assert!(emitterChainId == remoteChainId)
    assert!(emitterAddress == remoteTokenBridgeId)
    assert!(targetChainId == localChainId || targetChainId == 0)
    assert!(msgSequence >= receivedSequence)
    receivedSequence = msgSequence + 1

    assert!(byteVecSlice!(payload, 0, 1) == #02) // payload id
    let tokenId = byteVecSlice!(payload, 1, 33)
    let tokenChainId = u256From2Byte!(byteVecSlice!(payload, 33, 35))
    let decimals = u256From1Byte!(byteVecSlice!(payload, 35, 36))
    let symbol = byteVecSlice!(payload, 36, 68)
    let name = byteVecSlice!(payload, 68, 100)
    assert!(size!(payload) == 100)

    let path = #01 ++ u256To2Byte!(remoteChainId) ++ localTokenBridgeId
    let tokenBridgeForChainId = blake2b!(blake2b!(path))
    let tokenBridgeForChain = TokenBridgeForChain(tokenBridgeForChainId)
    tokenBridgeForChain.createWrapperForRemoteToken{payer -> createContractAlphAmount}(
      tokenId, decimals, symbol, name, payer, createContractAlphAmount
    )
  }
}

